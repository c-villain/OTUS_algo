# Хэш-таблицы
## Домашнее задание

### Цель: Создать хэш-таблицу

1 часть. 

Реализовать хеш-таблицу, использующую метод цепочек.

Методы к реализации: 

- void put(K key, V value) - вставка/замена элемента 
- V get(K key) - поиск элемента 
- V del(K key) - удаление элемента 
- void rehash() - рехеширование по достижению 75% заполнения int hash(K key)

Протестировать работу алгоритма. 

Для различных значений N степени 10: 10, 100, 1000, ... Максимальное количество элементов такое, чтобы программа работала не дольше двух минут.

Создать пустую таблицу. 

Добавить N пар записей такого вида: Key: random(0, N-1).toString() Val: тоже самое значение как число 

Искать N случайных чисел. Удалить N/10 случайных элементов.

Заполнить таблицу производительности и сделать вывод.

2 часть. 
Реализовать хеш-таблицу, использующую открытую адресацию, 

Методы к реализации:

- void put(K key, V value) - вставка/замена элемента 
- V get(K key) - поиск элемента 
- V del(K key) - удаление элемента 
- void rehash() - рехеширование по достижению 75% заполнения 
- int hash(K key, int i) - хэширование на i-ом пробинге
- 
Реализовать вариант линейного, квадратичного и двойного пробинга

## Выводы

### [Hash tables](https://en.wikipedia.org/wiki/Hash_table) / [Хеш-таблица](https://ru.wikipedia.org/wiki/Хеш-таблица)

> тесты в [main.swift](https://github.com/c-villain/OTUS_algo/blob/main/HW7/BinarySearchTrees/main.swift)

> let N = 2_000 элементов

  
 Operation with trees                     |BST with randoms|AVL with randoms|BST with increasing|AVL with increasing
  ---|---:|---:|---:|---:
 Creation (Insertion)                     |0.008           | 19             |0.2                |19      
 Searching                                |0.006           | 0.005          |0.2                |0.004     
 Removing                                 |0.006           | 0.004          |30                 |0.003       
 
 > let N = 3_000 элементов
 
  Operation with trees                    |BST with randoms |AVL with randoms|BST with increasing|AVL with increasing
  ---|---:|---:|---:|---:
 Creation (Insertion)                     |0.01             | 47             |0.42               |47      
 Searching                                |0.008            | 0.007          |0.42               |0.007     
 Removing                                 |0.007            | 0.007          |194                |0.006       
 
 Объяснение результата: на практике подтверилось, что в худшем случае (когда добавляются только возрастающие элементы) сложность работы с BST растет линейно, в том время, как в случае с AVL, она растет логарифмически. Кроме того, видно, что сложность работы в сбалансированном дереве поиска не меняется и остается _O(log n)_ как в случае, когда работа происходит с произвольными числами, так и в случае с возрастающими. Наоборот, в BST - во втором случае, с возрастающими числами - сложность становится уже линейной, а не логарифмической.
