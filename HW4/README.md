# Динамические массивы, неполный массив, очередь с приоритетом.
## Домашнее задание
### Цель: создание разных алгоритмов для реализации Динамического массива и сравнение их производительности. Создание приоритетной очереди или неполного массива.

1 задание. Динамические массивы.
Написать метод добавления и удаления элементов:
void add(T item, int index);
T remove(int index); // возвращает удаляемый элемент
по индексу во все варианты динамических массивов:
SingleArray, VectorArray, FactorArray, MatrixArray *.

2 задание. Таблица сравнения производительности.
Сравнить время выполнения разных операций 
для разных массивов с разным порядком значений.
* сделать обёртку над ArrayList() и тоже сравнить.
Составить таблицу и приложить её скриншот. 
Сделать выводы и сформулировать их в нескольких предложениях.

3 задание. Приоритетная очередь (на выбор).
Написать реализацию PriorityQueue - очередь с приоритетом.
Варианты реализации - список списков, массив списков
Методы к реализации:
enqueue(int priority, T item) - поместить элемент в очередь
T dequeue() - выбрать элемент из очереди

4 задание. Неполный массив (на выбор).
Написать Реализацию класса SpaceArray массив массивов с неполным заполнением. 
Делать на основе одного из уже созданных массивов и/или списков.

# Базовые структуры данных

## SingleArray, VectorArray, FactorArray, PriorityQueue

> тесты в [main.swift](https://github.com/c-villain/OTUS_algo/blob/main/HW4/Otus_algo/main.swift)

> реализация [PriorityQueue](https://github.com/c-villain/OTUS_algo/blob/main/HW4/Otus_algo/HW4/PriorityQueue/PriorityQueue.swift), тест использования также в [main.swift](https://github.com/c-villain/OTUS_algo/blob/main/HW4/Otus_algo/main.swift)

### Затраты времени на 200_000 операций, мс

Контейнер|Вставка начало|Вставка случайная|Вставка конец|Чтение начало|Чтение случайное|Чтение конец|Удаление начало|Удаление случайное|Удаление конец 
---|---:|---:|---:|---:|---:|---:|---:|---:|---:
SingleArray       |4160|2295|282|0|0|0|3734|2085|124
VectorArray       |4034|2240|303|0|0|0|3793|2021|137
FactorArray       |3954|2066|123|0|0|0|3834|2081|133
NativeArray(Apple)|3852|2022|105|0|0|0|3790|1999|117

### Вывод 
Мне лично было интересно сравнить кастомные реализации массивов с нативной реализацией динамического массива от Apple. Из документации Apple можно сделать вывод, что по сути нативная реализация - реализация factor array (по всей видимости со своим множителем), что косвенно подтверждается, в том числе и проведенными тестами, а также временем их выполнения, которое различается незначительно. **_Поэтому при прочих равных, смысла в кастомной имплементации (то есть использовании функции reserveCapacity() ) размерности массива нет, за исключением случая, когда заранее известно, сколько элементов будет в массиве (чтобы не выделять "лишнюю" память)_**.

Ожидаемо, factorArray в кастомных массивах имеет самую быструю вставку элемента, но операция удаления занимает большее время, чем у остальных (объясняется триггером проверки оставшейся "лишней" памяти после удаления)
