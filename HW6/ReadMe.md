# Сортировка Миллиарда чисел
## Домашнее задание
### Цель: Отсортировать миллиард чисел двумя способами: внешней и линейной сортировкой.
1. Сгенерировать бинарный файл, который содержит N целых, 16-битных чисел (от 0 до 65535), по 2 байта на каждое число.
Подобрать N для вашего языка программирования: 1e6, 1e7, 1e8, 1e9 или даже больше.
2. Написать алгоритм сортировки слиянием для сортировки файла - внешняя сортировка и замерить время его работы.
3. Использовать для сортировки небольших кусков (от 32 до 1024 чисел) другой алгоритм сортировки на выбор (quick, heap, shell) и сравнить время сортировки "комбинированным" алгоритмом.
4. Отсортировать числа одним из методов линейной сортировки, написать, какой выбрали:
а. Блочная сортировка.
б. Сортировка подсчётом.
в. Поразрядная сортировка.
4. Опубликовать таблицу сравнения быстродействия алгоритмов 2, 3 и 4, сделать выводы.


## Выводы

### [Merge sort](https://www.geeksforgeeks.org/merge-sort/) / [Сортировка слиянием (внешняя сортировка)](https://ru.wikipedia.org/wiki/Сортировка_слиянием)

[Визуализация работы алгоритма](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

Внешняя сортировка относится к классу квазилинейных, сложность алгоритма составляет _O (n log n)_

 MergeSorting                     |1000 |100.000|1.000.000|10.000.000|100.000.000
  ---|---:|---:|---:|---:|---:
 Standart implementation          |0.01 | 1.44  |17.21    |204       | x 
 Merge with Shell for 1024 items  |0.01 | 1.45  |16.45    |195       | x
 Merge with Heap for 1024 items   |0.007| 1.22  |15.16    |180       | x
 
 Как видим из таблицы, сложность на практике подтверждается, но при этом, если немного доработать алгоритм: не разбивать массив до вырожденного случая (делить до одного элемента), а остановиться на блоках, например, из 1024 элементов и применить к этим блокам другую сортировку ([Шелла](https://en.wikipedia.org/wiki/Shellsort) или [пирамидальную](https://en.wikipedia.org/wiki/Heapsort)), то время сортировки сокращается. С пирамидальной сортировкой - квазилинейным алгоритмом - ожидаемо работает быстрее.
 
 ### [Linear sort](https://www.geeksforgeeks.org/merge-sort/) / [Линейные алгориитмы](https://ru.wikipedia.org/wiki/Алгоритм_сортировки#Алгоритмы,_не_основанные_на_сравнениях)

Линейные алгоритмы, то есть алгоритмы работащие за линейное время, не основаны на сравнениях.

[Визуализация работы алгоритма bucket sort.](https://www.cs.usfca.edu/~galles/visualization/BucketSort.html)

[Визуализация работы алгоритма counting sort.](https://www.cs.usfca.edu/~galles/visualization/CountingSort.html)

Сложность: при удачных входных данных или данных, о которых мы знаем допольнительную информацию (как в примере на практике: массив состоит из двухбайтных чисел с максимальным элементом - 65535) _O(n)_

На практике рассмотрены [блочный алгоритм](https://ru.wikipedia.org/wiki/Блочная_сортировка) ([bucket sort](https://en.wikipedia.org/wiki/Bucket_sort)), а также его другая версия, доработанная [сортировкой подсчета](https://ru.wikipedia.org/wiki/Сортировка_подсчётом) ([сounting sort](https://en.wikipedia.org/wiki/Counting_sort) ). 
 
 BucketSorting               |1000 |100.000|1.000.000|10.000.000|100.000.000 |1.000.000.000
  ---|---:|---:|---:|---:|---:|---:
 Standart implementation     |0.002| 0.17  |1.67     |18        | 236        | x
 Bucket with Heap            |0.003| 0.27  |2.75     |28        | 300        | x
 Bucket with Count           |0.00 | 0.11  |0.77     |7.3       | 72         | 13 min
 
 #### Пояснения к таблице 
 
**_[Standart implementation (стандартная реализация)](https://github.com/c-villain/OTUS_algo/blob/main/HW6/MergeAndLinearSorts/HW6/BucketSorting/BucketSort.swift)_** - блочный алгоритм, где при перемещении очередного элемента в корзину, мы путем сравнения ставим его на правильную позицию, то есть элементы в корзине сортируются при добавлении (сортировка работает быстро, так как математическое ожидание количества элементов в корзине стремится к 1). Реализация алгоритма в этом случае [стабильна или устойчива](https://ru.wikipedia.org/wiki/Устойчивая_сортировка).

**_[Bucket with Heap (блочный алгоритм с внутренней пирамидальной сортировкой)](https://github.com/c-villain/OTUS_algo/blob/main/HW6/MergeAndLinearSorts/HW6/BucketSorting/BucketWithHeapSorting.swift)_** - блочный алгоритм, в котором мы сортируем пирамидальным алгоритмом (можно выбрать и другой) элементы в корзине после того, как все корзины заполнены, реализация в общем случае не устойчива засчет внутренней пирамидальной сортировки.

**_[Bucket with Count (комбинация блочной сортировки и сортировки подсчетом)](https://github.com/c-villain/OTUS_algo/blob/main/HW6/MergeAndLinearSorts/HW6/BucketSorting/BucketWithCountSorting.swift)_**: так как заранее известна дополнительная информация про сортируемый массив, что он состоит из двухбайтных чисел, то можно  улучшить алгоритм блочной сортировки алгоритмом подсчета, а именно: создаем изначально k+1 блоков, где k - max элемент массива - число 65535.
После этого в каждый блок, у которого номер - очередной элемент изначального массива, попадает число = сколько раз встречается этот очередной элемент, это и есть подсчет. После выписываем согласно подсчету отсортированный массив. Реализация алгоритма не является устойчивой. Но на практике ожидаемо является самым быстрым и позволил отсортировать миллиард чисел за адекватное время - около 13 мин.



