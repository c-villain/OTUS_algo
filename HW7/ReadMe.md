# Двоичное дерево поиска, АВЛ.
## Домашнее задание

### Цель: Создать двоичное дерево поиска, реализовать один из вариантов балансировки. 

Сравнить эффективность алгоритмов на случайных и упорядоченных данных.

1 часть, обязательная.

Создать простейшее двоичное дерево поиска. 

Методы к реализации:

void insert(int x) - вставка элемента

bool search(int x) - поиск элемента

void remove(int x) - удаление элемента

Протестировать работу алгоритма.
Создать два дерева (максимальный размер дерева выберите такой, чтобы программа работала не дольше 1 минуты)
Добавить N чисел в случайном (первое) и возрастающем (второе) порядке.
Искать N/10 случайных чисел в каждом дереве.
Удалить N/10 случайных элементов в каждом дереве.

Заполнить таблицу производительности и сделать вывод.

2 часть.

Расширить класс из 1 части и создать сбалансированное АВЛ-дерево.

Методы к реализации:

smallLeftRotation(Tree t) smallRightRotation(Tree t) - малое левое/правое вращение

bigLeftRotation(Tree t), bigRightRotation(Tree t) - большое левое/правое вращение, написать через вызов малых вращений

void insert(int x) - вставка элемента

void remove(int x) - удаление элемента

void rebalance(Tree t) - перебалансировка дерева

Протестировать работу алгоритма аналогичным образом,
дополнить таблицу производительности, сделать вывод.


## Выводы

### [Binary search tree (BST)](https://en.wikipedia.org/wiki/Binary_search_tree) / [Двоичное дерево поиска](https://ru.wikipedia.org/wiki/Двоичное_дерево_поиска)

[Визуализация работы двоичного дерева поиска](https://www.cs.usfca.edu/~galles/visualization/BST.html)

 Сложность операций в BST         |В среднем |В худшем
  ---|---:|---:
 Поиск                            |O(log n)  | O(n)
 Вставка                          |O(log n)  | O(n)
 Удаление                         |O(log n)  | O(n)


[AVL tree](https://en.wikipedia.org/wiki/AVL_tree) / [Сбалансированное двочиное дерево поиска](https://ru.wikipedia.org/wiki/АВЛ-дерево) - дерево, у которого для каждой его вершины высота её двух поддеревьев различается не более чем на 1.

[Визуализация работы сбалансированного двоичного дерева поиска](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)

 Сложность операций в AVL         |В среднем |В худшем
  ---|---:|---:
 Поиск                            |O(log n)  | O(log n)
 Вставка                          |O(log n)  | O(log n)  
 Удаление                         |O(log n)  | O(log n) 

### Таблица производительности в деревьях BST и AVL (в сек)

> тесты в [main.swift](https://github.com/c-villain/OTUS_algo/blob/main/HW7/BinarySearchTrees/main.swift)

Операции:
1. Создать по два дерева (для BST и AVL). Добавить N чисел в случайном (первое) и возрастающем (второе) порядке.
2. Искать N/10 случайных чисел в каждом дереве.
3. Удалить N/10 случайных элементов в каждом дереве.

> let N = 2_000 элементов

  
 Operation with trees                     |BST with randoms|AVL with randoms|BST with increasing|AVL with increasing
  ---|---:|---:|---:|---:
 Creation (Insertion)                     |0.008           | 19             |0.2                |19      
 Searching                                |0.006           | 0.005          |0.2                |0.004     
 Removing                                 |0.006           | 0.004          |30                 |0.003       
 
 > let N = 3_000 элементов
 
  Operation with trees                    |BST with randoms |AVL with randoms|BST with increasing|AVL with increasing
  ---|---:|---:|---:|---:
 Creation (Insertion)                     |0.01             | 47             |0.42               |47      
 Searching                                |0.008            | 0.007          |0.42               |0.007     
 Removing                                 |0.007            | 0.007          |194                |0.006       
 
 Объяснение результата: на практике подтверилось, что в худшем случае (когда добавляются только возрастающие элементы) сложность работы с BST растет линейно, в том время, как в случае с AVL, она растет логарифмически. Кроме того, видно, что сложность работы в сбалансированном дереве поиска не меняется и остается _O(log n)_ как в случае, когда работа происходит с произвольными числами, так и в случае с возрастающими. Наоборот, в BST - во втором случае, с возрастающими числами - сложность становится уже линейной, а не логарифмической.
